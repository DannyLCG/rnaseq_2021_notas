---
title: "clase03-ModelosEstadisticos"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


(~10) podemos usar la funcion model.matrix
El objeto 'trees' es un df. (model.matrix convierte a 0s y 1s ~0:15)
```{r}
# ?model.matrix
# la '~' separa a la variable 'y' del lado izq. y 'x' del lado der.
# '+' indica que tenemos mas de una variable para nuestras variables 'x' o 'y'
mat <- with(trees, model.matrix(log(Volume) ~ log(Height) + log(Girth)))
mat
```
¿Cómo interpretamos los nombres de las columnas de mat?
Observamos la seccion 'coefficients'
el logaritmo de la altura vs el volumen del arbol :(~0:25)
En genomica ... obtenemos el valor estimado y el valor Pr (~0:25)
```{r}
summary(lm(log(Volume) ~ log(Height) + log(Girth), data = trees))
```

5.1 ExploreModelMatrix
En este moelo queremos (~30)
```{r}
## Datos de ejemplo
(sampleData <- data.frame(
    genotype = rep(c("A", "B"), each = 4),
    treatment = rep(c("ctrl", "trt"), 4)
))
```
(sobre los parametros y para que sirve visualizar ~0:30)

```{r}
## Creemos las imágenes usando ExploreModelMatrix
vd <- ExploreModelMatrix::VisualizeDesign(
    sampleData = sampleData,
    designFormula = ~ genotype + treatment,
    textSizeFitted = 4
)

## Veamos las imágenes
cowplot::plot_grid(plotlist = vd$plotlist)
```
De forma interactiva podemos usar el siguiente codigo:
```{r}
library(ExploreModelMatrix)
## Usaremos shiny otra ves
app <- ExploreModelMatrix(
    sampleData = sampleData,
    designFormula = ~ genotype + treatment
)
if (interactive()) shiny::runApp(app)
```

Ejemplo2
Podemos interpretar la tabla del objeto ExploreModelMatrix
restando la primera columna de la segunda.

Ejemplo3
Si no queremos usar la variable 'intercept' escribimos un '0' despues de la tilde
(elminar la variable 'conditionko_minus' ~1:00)

5.2 Datos de SRP045638
```{r}
library("recount3")

human_projects <- available_projects()

rse_gene_SRP045638 <- create_rse(
    subset(
        human_projects,
        project == "SRP045638" & project_type == "data_sources"
    )
)
```

```{r}
assay(rse_gene_SRP045638, "counts") <- compute_read_counts(rse_gene_SRP045638)

```

Una vez descargados y con los números de lecturas podemos usar expand_sra_attributes(). Sin embargo, tenemos un problema con estos datos.

```{r}
rse_gene_SRP045638$sra.sample_attributes[1:3]
#Podemos observar que las columnas tenemos el mismo # de columnas...
```

Vamos a intentar resolverlo eliminando información que está presente solo en ciertas muestras.
```{r}
rse_gene_SRP045638$sra.sample_attributes <- gsub("dev_stage;;Fetal\\|", "",   rse_gene_SRP045638$sra.sample_attributes)
rse_gene_SRP045638$sra.sample_attributes[1:3]
```

Ahora si podemos continuar con el mismo código de ayer.
```{r}
rse_gene_SRP045638 <- expand_sra_attributes(rse_gene_SRP045638)

colData(rse_gene_SRP045638)[
    ,
    grepl("^sra_attribute", colnames(colData(rse_gene_SRP045638)))
]
#observamos que algunas columnas necesitan cambiarse de tipo de dato...
```

Como ahora si vamos a usar esta información para un modelo estadístico, será importante que tengamos en el formato correcto de R a la información que vamos a usar.
```{r}
## Pasar de character a nuemric o factor
rse_gene_SRP045638$sra_attribute.age <- as.numeric(rse_gene_SRP045638$sra_attribute.age)
rse_gene_SRP045638$sra_attribute.disease <- factor(rse_gene_SRP045638$sra_attribute.disease)
rse_gene_SRP045638$sra_attribute.RIN <- as.numeric(rse_gene_SRP045638$sra_attribute.RIN)
rse_gene_SRP045638$sra_attribute.sex <- factor(rse_gene_SRP045638$sra_attribute.sex)

## Resumen de las variables de interés
summary(as.data.frame(colData(rse_gene_SRP045638)[
    ,
    grepl("^sra_attribute.[age|disease|RIN|sex]", colnames(colData(rse_gene_SRP045638)))
]))
```

Ahora crearemos un par de variables para que las podamos usar en nuestro análisis.
```{r}
## Encontraremos diferencias entre muestra prenatalas vs postnatales
rse_gene_SRP045638$prenatal <- factor(ifelse(rse_gene_SRP045638$sra_attribute.age < 0, "prenatal", "postnatal"))
table(rse_gene_SRP045638$prenatal)
```

Creamos otra variable lecturas aosciadas a genes/(~1:30)
```{r}
## http://research.libd.org/recount3-docs/docs/quality-check-fields.html
rse_gene_SRP045638$assigned_gene_prop <- rse_gene_SRP045638$recount_qc.gene_fc_count_all.assigned / rse_gene_SRP045638$recount_qc.gene_fc_count_all.total
summary(rse_gene_SRP045638$assigned_gene_prop)
```

```{r}
# Hm... veamos si hay una diferencia entre los grupos
with(colData(rse_gene_SRP045638), tapply(assigned_gene_prop, prenatal, summary))
```
A continuación podemos eliminar algunas muestras que consideremos de baja calidad y genes con niveles de expresión muy bajos. (y que no hay diferencias marcadas)

```{r}
## Guardemos nuestro objeto entero por si luego cambiamos de opinión
rse_gene_SRP045638_unfiltered <- rse_gene_SRP045638

## Eliminemos a muestras malas
hist(rse_gene_SRP045638$assigned_gene_prop)
```
Sobre el criterio(~1:40)
```{r}
table(rse_gene_SRP045638$assigned_gene_prop < 0.3)
```

```{r}
rse_gene_SRP045638 <- rse_gene_SRP045638[, rse_gene_SRP045638$assigned_gene_prop > 0.3]

## Calculemos los niveles medios de expresión de los genes en nuestras
## muestras.
## Ojo: en un análisis real probablemente haríamos esto con los RPKMs o CPMs
## en vez de las cuentas.
gene_means <- rowMeans(assay(rse_gene_SRP045638, "counts"))
summary(gene_means)
```
(sobre porque eliminamos genes ~1:42)
```{r}
## Eliminamos genes
rse_gene_SRP045638 <- rse_gene_SRP045638[gene_means > 0.1, ]

## Dimensiones finales
dim(rse_gene_SRP045638)
```
```{r}
## Porcentaje de genes que retuvimos
round(nrow(rse_gene_SRP045638) / nrow(rse_gene_SRP045638_unfiltered) * 100, 2)
```

Ahora ya estamos listos para continuar con el análisis de expresión diferencial, bueno, casi.

